package hu.mktiti.tulkas.server.data.repo

import hu.mktiti.kreator.api.inject
import hu.mktiti.tulkas.server.data.dao.ConnectionSource
import java.sql.Connection
import java.sql.PreparedStatement
import java.sql.Savepoint
import java.sql.Statement.NO_GENERATED_KEYS
import java.sql.Statement.RETURN_GENERATED_KEYS
import java.util.*

private class ConnectionContext(
        val connection: Connection
) {
    var hasRoot = false
        private set

    private val transaction = Transaction(connection)

    private fun createGuard(): Savepoint {
        if (!hasRoot && connection.autoCommit) {
            connection.autoCommit = false
        }
        hasRoot = true
        return connection.setSavepoint()
    }

    private fun <R> executeWithGuard(guard: Savepoint?, block: Transaction.() -> R): R {
        try {
            val result = transaction.block()
            if (guard != null) {
                connection.releaseSavepoint(guard)
            }
            return result
        } catch (exception: Exception) {
            if (guard != null) {
                connection.rollback(guard)
            }

            if (exception is RollbackException) {
                throw exception
            } else {
                throw RollbackException(exception)
            }

        }
    }

    fun <R> executeFlattened(block: Transaction.() -> R): R {
        val isRoot = !hasRoot
        try {
            return executeWithGuard(if (isRoot) createGuard() else null, block)
        } finally {
            if (isRoot) {
                connection.commit()
                hasRoot = false
            }
        }
    }

    fun <R> executeGuarded(block: Transaction.() -> R): TransactionResult<R> {
        val isRoot = !hasRoot
        return try {
            CommitResult(executeWithGuard(createGuard(), block))
        } catch (re: RollbackException) {
            RollbackResult()
        } finally {
            if (isRoot) {
                connection.commit()
                hasRoot = false
            }
        }
    }
}

fun AutoCloseable.safeClose() = use { }

private object ConnectionStore {

    val connectionSource: ConnectionSource = inject()

    private val localStack: ThreadLocal<Stack<ConnectionContext>> = object : ThreadLocal<Stack<ConnectionContext>>() {
        override fun initialValue() = Stack<ConnectionContext>()
    }

    private fun createNew(): ConnectionContext = ConnectionContext(connectionSource()).let(localStack.get()::push)

    private fun getOrCreate(): Pair<ConnectionContext, Boolean> = with(localStack.get()) {
        if (isEmpty()) {
            createNew() to true
        } else {
            peek() to false
        }
    }

    fun <R> withoutTransaction(code: Connection.() -> R): R {
        var (context, newlyCreated) = getOrCreate()
        if (!newlyCreated && context.hasRoot) {
           context = createNew()
            newlyCreated = true
        }

        val result = context.connection.code()

        if (newlyCreated) {
            localStack.get().pop()
            context.connection.safeClose()
        }

        return result
    }

    fun <R> withAny(code: ConnectionContext.() -> R): R {
        val (context, newlyCreated) = getOrCreate()
        val result = context.code()
        if (newlyCreated) {
            localStack.get().pop().connection.safeClose()
        }
        return result
    }

    fun <R> withNew(code: ConnectionContext.() -> R): R {
        val result = createNew().code()
        localStack.get().pop().connection.safeClose()
        return result
    }

}

sealed class TransactionResult<T>

class CommitResult<T>(val result: T) : TransactionResult<T>()

class RollbackResult<T> : TransactionResult<T>()

class RollbackException(cause: Exception? = null) : RuntimeException("Rollback occured in transaction", cause)

class Transaction(
        private val connection: Connection
) {

    fun prepare(sql: String, autoGenerated: Boolean = true): PreparedStatement =
            connection.prepareStatement(sql, if (autoGenerated) RETURN_GENERATED_KEYS else NO_GENERATED_KEYS)

    fun savePoint(): Savepoint = connection.setSavepoint()

    fun rollback(savepoint: Savepoint) = connection.rollback(savepoint)

    fun rollback(): Nothing = throw RollbackException()

}

fun <R> withoutTransaction(code: Connection.() -> R): R =
        ConnectionStore.withoutTransaction(code)

fun <R> withConnection(code: Connection.() -> R): R =
        ConnectionStore.withAny { connection.code() }

fun <R> transaction(code: Transaction.() -> R): R =
        ConnectionStore.withAny { executeFlattened(code) }

fun <R> guardedTransaction(code: Transaction.() -> R): TransactionResult<R> =
        ConnectionStore.withAny { executeGuarded(code) }

fun <R : Any> guardedTransaction(code: Transaction.() -> R): R? {
    val result = ConnectionStore.withAny { executeGuarded(code) }
    return when (result) {
        is CommitResult   -> result.result
        is RollbackResult -> null
    }
}

fun guardedTransaction(code: Transaction.() -> Unit): Boolean =
        ConnectionStore.withAny { executeGuarded(code) is CommitResult }

fun <R> newTransaction(code: Transaction.() -> R): TransactionResult<R> = ConnectionStore.withNew { executeGuarded(code) }

fun <R : Any> newTransaction(code: Transaction.() -> R): R? {
    val result = ConnectionStore.withNew { executeGuarded(code) }
    return when (result) {
        is CommitResult   -> result.result
        is RollbackResult -> null
    }
}

fun newTransaction(code: Transaction.() -> Unit): Boolean =
        ConnectionStore.withNew { executeGuarded(code) is CommitResult }